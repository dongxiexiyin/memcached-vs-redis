Memcached的特点：
1、memcached本身不提供分布式解决方案，在服务器端，memcached集群环境实际就是一个个memcached服务器的堆积，环境搭建较为简单；cache的分布式主要是在客户端实现，通过客户端的路由算法来达到分布式解决方案的目的。客户端做路由的原理非常简单，应用服务器在每次存取key的value时，通过路由算法把key映射到某台memcached服务器上，因此这个key所有的操作都在这台服务器上进行。只要服务器还缓存着该数据，就能保证缓存命中。
2、memcached客户端采用一致性hash算法作为路由策略，相对于一般的hash算法，一致性hash除了计算key的hash值外，还会计算每个server对应的hash值，然后将这些hash值映射到一个有限的值域上。通过寻找hash值大于hash(key)的最小server作为存储该key数据的目标server。如果找不到，则直接把具有最小hash值的server作为目标server。同时，一定程度上，解决了扩容的问题。增加或删除节点不会对整个集群造成太大影响。
3、为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。由于数据仅存在于内存中，因此重启memcached、重启操作系统会导致全部数据消失。另外，缓存的内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。memcached本身是为缓存而设计的服务，因此并没有过多考虑数据的永久性问题。这也是为什么memcached比较快的原因。
4、slab是一个内存块，它是memcached一次申请内存的最小单位。但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。Slab的大小固定为1M，一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。memcached内存管理采取预分配、分组管理的方式，分组管理就是我们上面提到的slab class，按照chunk的大小slab被分为很多种类。内存预分配过程是怎样的呢？向memcached添加一个item时候，memcached首先会根据item的大小，来选择最合适的slab class：例如item的大小为190字节，默认情况下class 4的chunk大小为160字节显然不合适，class 5的chunk大小为200字节，大于190字节，因此该item将放在class 5中（显然这里会有10字节的浪费是不可避免的），计算好所要放入的chunk之后，memcached会去检查该类大小的chunk还有没有空闲的，如果没有，将会申请1M（1个slab）的空间并划分为该种类chunk。例如我们第一次向memcached中放入一个190字节的item时，memcached会产生一个slab class 2（也叫一个page），并会用去一个chunk，剩余5241个chunk供下次有适合大小item时使用，当我们用完这所有的5242个chunk之后，下次再有一个在160～200字节之间的item添加进来时，memcached会再次产生一个class 5的slab（这样就存在了2个pages）。
5、使用场景：key-value能满足需求的前提下，使用memcached分布式集群是较好的选择，搭建与操作使用都比较简单；分布式集群在单点故障时，只影响小部分数据异常，目前还可以通过Magent缓存代理模式，做单点备份，提升高可用；整个缓存都是基于内存的，因此响应时间是很快，不需要额外的序列化、反序列化的程序，但同时由于基于内存，数据没有持久化，集群故障重启数据无法恢复。高版本的memcached已经支持CAS模式的原子操作，可以低成本的解决并发控制问题。

Redis的特点：
1、支持的数据类型丰富，能够支持更复杂的结构和操作。最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。
2、redis支持数据持久化并提供了两种数据持久化的方式：RDB（Redis DataBase）和AOF（Append Only File）。 RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。而AOF方式是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
3、Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。这确保如果两个客户端并发访问，Redis服务器能接收更新的值。
4、在内存管理机制上，redis并不是把所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。
5、Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。Redis通过定义一个数组来记录所有的内存分配情况，数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。
6、Redis支持master-slave模式的数据备份。
7、使用场景：redis在响应速度方面要比memcached快不少；在key-value较多并且数据类型较为复杂，或者对于数据持久性有较高要求的公司来说，redis是不二选择。